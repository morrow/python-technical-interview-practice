1. The approach I took with this question was to use a dictionary to store the characters of t, and then iterate through the characters of s in order, and lookup whether the character exists in t. I use the dictionary to track which values of t have been found in s, and then perform some checks to see if an anagram has been found. The reasoning for this approach is that I can take advantage of a dictionary's O(1) lookup time to keep time complexity minimal. With this, my time complexity would be approximated at O(n).

2. I took a dynamic programming approach for this problem, in order to break down the problem into smaller subproblems. I used helper functions to solve each subtask, which I defined as the following: findPalindromes - find initial palindromes in the string by looking for the midpoint of the palindrome and store the left and right indices of the palindrome. expandPalindromes - expand each palindrome by moving it's left and right bounds outward and check if it's still a palindrome. findBiggestPalindrome - Find the biggest palindrome among the expanded palindromes. This approach offers a best case O(n) time complexity and a worst case of O()

3. I combined dynamic programming to split the problem into smaller parts as well as using Kruskal's algorithm to find the minimum spanning tree. I use Node, Edge, and Graph objects to make the problem more approachable. Time complexity for creating the graph is O(nm) where n is the number of nodes and m is the number of edges per node. I use a set to avoid having to check for existence of edge in edges array, so that there are not duplicate edges represented. Time complexity of the minimum_spanning_tree function is O(n) where n is the number of edges in the graph. However, this requires a sorted edges array, which increases the time complexity to O(log(n)).

4. For this approach I used a recursive algorithm called least_common_ancestor to search through the nodes for the least common ancestor. Since we know that this is a Binary Search Tree, we can traverse from the root and simply compare the value of our search nodes to the value of the current node to know which branch left or right to follow next. Time complexity is O(n) thanks to the fact that the properties of binary search trees allow us to start at the root node and iterate through in linear time.

5. I created classes for Node and LinkedList elements. I implemented two problems in LinkedList for appending elements and calculating elements from last element. This is done by storing a variable 'count' which keeps track of how many elements have been added to the list as they are added. This allows for a O(n) runtime.